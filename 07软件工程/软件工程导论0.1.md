软件工程导论
----------------------------


>auther：forbid  
data：2020/10/31   
version：0.1  
附加说明：该文章的内容很多来自网络上的资料，这个不用于商业用途，如有侵权等问题请联系本人。  
文件说明：该文件的书本《软件工程导论》（第六版）—— 张海藩 的基本内容，作为第一次学习软件工程。


<!-- TOC -->

- [1. 软件工程学概述](#1-软件工程学概述)
  - [1.1 软件危机](#11-软件危机)
    - [1.1.1 软件危机的介绍](#111-软件危机的介绍)
    - [1.1.1软件危机产生的原因](#111软件危机产生的原因)
    - [1.1.1消除软件危机的途径](#111消除软件危机的途径)
  - [1.2 软件工程](#12-软件工程)
    - [1.2.1 软件 =  程序 + 数据 + 文档](#121-软件---程序--数据--文档)
    - [1.2.2 介绍](#122-介绍)
    - [1.2.3 基本原理](#123-基本原理)
    - [1.2.4 方法学](#124-方法学)
      - [1.2.4.1 传统方法学](#1241-传统方法学)
      - [1.2.4.2 面向对象方法学](#1242-面向对象方法学)
  - [1.3 软件生命周期](#13-软件生命周期)
  - [1.4 软件过程](#14-软件过程)
    - [1.4.1 瀑布模型](#141-瀑布模型)
    - [1.4.2 快速原型模型](#142-快速原型模型)
    - [1.4.3 增量模型（渐增模型）](#143-增量模型渐增模型)
    - [1.4.4 螺旋模型](#144-螺旋模型)
    - [1.4.5 喷泉模型](#145-喷泉模型)
    - [1.4.6 Rational统一过程](#146-rational统一过程)
    - [1.4.7 敏捷过程和极限编程](#147-敏捷过程和极限编程)
    - [1.4.7.1 敏捷过程——价值观](#1471-敏捷过程价值观)
    - [1.4.7.2 极限编程（敏捷过程的具体落实）](#1472-极限编程敏捷过程的具体落实)
    - [1.4.8 微软过程](#148-微软过程)
    - [1.4.9 小结](#149-小结)
- [2. 可行性研究](#2-可行性研究)
  - [2.1 可行性研究的任务](#21-可行性研究的任务)
  - [2.2 可行性研究过程](#22-可行性研究过程)
  - [2.3 系统流程图](#23-系统流程图)
  - [2.4 数据流图（DFD）](#24-数据流图dfd)
  - [2.5 数据字典](#25-数据字典)
  - [2.6 成本/效益](#26-成本效益)
  - [小结](#小结)
- [3. 需求分析](#3-需求分析)
  - [3.1 需求分析的任务](#31-需求分析的任务)
  - [3.2 与用户沟通获取需求的方法](#32-与用户沟通获取需求的方法)
  - [3.3 分析建模与规格说明](#33-分析建模与规格说明)
  - [3.4 实体-联系图](#34-实体-联系图)
  - [3.5 数据规范化](#35-数据规范化)
  - [3.6 状态转化图](#36-状态转化图)
  - [3.7 其他图形工具](#37-其他图形工具)
  - [3.8 验证软件需求](#38-验证软件需求)
  - [小结](#小结-1)
- [4. 形式化说明技术](#4-形式化说明技术)
  - [4.1 概述](#41-概述)
  - [4.2 有穷状态机](#42-有穷状态机)
  - [4.3 Petri网](#43-petri网)
  - [4.4 Z语言](#44-z语言)
- [5. 总体设计（概要设计）](#5-总体设计概要设计)
  - [5.1 设计过程](#51-设计过程)
  - [5.2 设计原理](#52-设计原理)
  - [5.3 启发规则](#53-启发规则)
  - [5.4 描绘软件结构的图形工具（模块）](#54-描绘软件结构的图形工具模块)
  - [5.5 面向数据流的设计方法](#55-面向数据流的设计方法)
  - [5.6 小结](#56-小结)
- [6. 详细设计](#6-详细设计)
  - [6.1 结构程序设计](#61-结构程序设计)
  - [6.2 人机界面设计](#62-人机界面设计)
  - [6.3 过程设计的工具](#63-过程设计的工具)
  - [6.4 面向数据结构的设计方法](#64-面向数据结构的设计方法)
  - [6.5 程序复杂程度的定量度量](#65-程序复杂程度的定量度量)
    - [McCabe方法](#mccabe方法)
    - [Halstead方法](#halstead方法)
- [7. 实现](#7-实现)
  - [7.1 编码](#71-编码)
    - [7.1.1 选择程序设计语言](#711-选择程序设计语言)
    - [7.1.2 编码风格](#712-编码风格)
  - [7.2 软件测试基础](#72-软件测试基础)
    - [7.2.1 软件测试的目标](#721-软件测试的目标)
    - [7.2.2 软件测试准则](#722-软件测试准则)
    - [7.2.3 测试方法](#723-测试方法)
    - [7.2.4 测试步骤](#724-测试步骤)
    - [7.2.5 测试阶段的信息流](#725-测试阶段的信息流)
  - [7.3 单元测试](#73-单元测试)
    - [7.3.1 测试重点](#731-测试重点)
  - [7.4 集成测试](#74-集成测试)
    - [7.4.1 自顶向下集成](#741-自顶向下集成)
    - [7.4.2 自底向上集成](#742-自底向上集成)
    - [7.4.3 不同集成测试策略的比较](#743-不同集成测试策略的比较)
    - [7.4.4 回归测试](#744-回归测试)
  - [7.5 确认测试](#75-确认测试)
    - [7.5.1 确认测试的范围](#751-确认测试的范围)
    - [7.5.2 软件配置复查](#752-软件配置复查)
    - [7.5.3 Alpha和Beta测试](#753-alpha和beta测试)
  - [7.6 白盒测试技术](#76-白盒测试技术)
    - [7.6.1 逻辑覆盖](#761-逻辑覆盖)
    - [7.6.2 控制结构测试](#762-控制结构测试)
  - [7.7 黑盒测试技术](#77-黑盒测试技术)
    - [7.7.1 等价划分](#771-等价划分)
    - [7.7.2 边界值分析](#772-边界值分析)
    - [7.7.3 错误推测](#773-错误推测)
  - [7.8 调试](#78-调试)
    - [7.8.1 调试过程](#781-调试过程)
    - [7.8.2 调试途径](#782-调试途径)
  - [7.9 软件可靠性](#79-软件可靠性)
    - [7.9.1 基本概念](#791-基本概念)
    - [7.9.2 估算平均无故障时间的方法](#792-估算平均无故障时间的方法)
- [8. 维护](#8-维护)
  - [8.1 软件维护的定义](#81-软件维护的定义)
  - [8.2 软件维护的特点](#82-软件维护的特点)
    - [8.2.1 结构化维护和非结构化维护的巨大差别](#821-结构化维护和非结构化维护的巨大差别)
    - [8.2.2 维护的代价高昂](#822-维护的代价高昂)
    - [8.2.3 维护的问题很多](#823-维护的问题很多)
  - [8.3 软件维护的过程](#83-软件维护的过程)
  - [8.4 软件的可维护性](#84-软件的可维护性)
    - [8.4.1 决定软件可维护性的因素](#841-决定软件可维护性的因素)
    - [8.4.2 文档](#842-文档)
    - [8.4.3 可维护复审](#843-可维护复审)
  - [8.5 预防性维护](#85-预防性维护)
  - [8.6 软件再工程过程](#86-软件再工程过程)
- [9. 面向对象方法学的引论](#9-面向对象方法学的引论)
  - [9.1 概述](#91-概述)
    - [9.1.2 优点](#912-优点)
  - [9.2 概念](#92-概念)
    - [9.2.1 对象](#921-对象)
    - [9.2.2 其他概念](#922-其他概念)
  - [9.3 面向对象建模](#93-面向对象建模)
  - [9.4 对象模型](#94-对象模型)
    - [9.4.1 类图的基本符号](#941-类图的基本符号)
    - [9.4.2 表示关系的符号](#942-表示关系的符号)
  - [9.5 动态模型](#95-动态模型)
  - [9.6 功能模型](#96-功能模型)
    - [9.6.1 用例图](#961-用例图)
    - [9.6.2 用例建模](#962-用例建模)
  - [9.7 3种模型之间的关系](#97-3种模型之间的关系)
  - [9.8 小结](#98-小结)
- [10. 面向对象分析](#10-面向对象分析)
  - [10.1 基本过程](#101-基本过程)
    - [10.1.1 概述](#1011-概述)
    - [10.1.2 3个子模型与5个层次](#1012-3个子模型与5个层次)
  - [10.2 需求陈述](#102-需求陈述)
    - [10.2.1 书写要点](#1021-书写要点)
    - [10.2.2 例子](#1022-例子)
  - [10.3 建立对象模型](#103-建立对象模型)
    - [10.3.1 确定类与对象](#1031-确定类与对象)
    - [10.3.2 确定关联](#1032-确定关联)
    - [10.3.3 划分主题](#1033-划分主题)
    - [10.3.4 确定属性](#1034-确定属性)
    - [10.3.5 识别继承关系](#1035-识别继承关系)
    - [10.3.6 反复修改](#1036-反复修改)
  - [10.4 建立动态模型](#104-建立动态模型)
    - [10.4.1 编写脚本](#1041-编写脚本)
    - [10.4.2 设想用户界面](#1042-设想用户界面)
    - [10.4.3 画事件跟踪图](#1043-画事件跟踪图)
    - [10.4.4 画状态图](#1044-画状态图)
    - [10.4.5 审查动态模型](#1045-审查动态模型)
  - [10.5 建立功能模型](#105-建立功能模型)
    - [10.5.1 画出基本系统模型图](#1051-画出基本系统模型图)
    - [10.5.2 画出功能级数据流图](#1052-画出功能级数据流图)
    - [10.5.3 描述处理框功能](#1053-描述处理框功能)
  - [10.6 定义服务](#106-定义服务)
  - [10.7 小结](#107-小结)
- [11. 面向对象设计](#11-面向对象设计)
  - [11.1 面向对象设计的准则](#111-面向对象设计的准则)
  - [11.2 启发规则](#112-启发规则)
  - [11.3 软件重用](#113-软件重用)
    - [11.3.1 概述](#1131-概述)
    - [11.3.2 类构件](#1132-类构件)
    - [11.3.3 软件重用的效益](#1133-软件重用的效益)
  - [11.4 系统分解](#114-系统分解)
  - [11.5 设计问题域子系统](#115-设计问题域子系统)
  - [11.6 设计人机交互子系统](#116-设计人机交互子系统)
  - [11.7 设计任务管理子系统](#117-设计任务管理子系统)
  - [11.8 设计数据管理子系统](#118-设计数据管理子系统)
    - [11.8.1 选择数据存储管理模式](#1181-选择数据存储管理模式)
    - [11.8.2 设计数据管理子系统](#1182-设计数据管理子系统)
    - [11.8.3 例子](#1183-例子)
  - [11.9 设计类中的服务](#119-设计类中的服务)
    - [11.9.1 确定类中应用的服务](#1191-确定类中应用的服务)
    - [11.9.2 设计实现服务的方法](#1192-设计实现服务的方法)
  - [11.10 设计关联](#1110-设计关联)
  - [11.11 设计优化](#1111-设计优化)
    - [11.11.1 确定优先级](#11111-确定优先级)
    - [11.11.2 提高效率的几项技术](#11112-提高效率的几项技术)
    - [11.11.3 调整继承关系](#11113-调整继承关系)
  - [11.12 小结](#1112-小结)
- [12 面向对象实现](#12-面向对象实现)
  - [12.1 程序设计语言](#121-程序设计语言)
    - [12.1.1 面向对象语言的优点](#1211-面向对象语言的优点)
    - [12.1.2 面向对象语言的技术特点](#1212-面向对象语言的技术特点)
    - [12.1.3 选择面向对象语言](#1213-选择面向对象语言)
  - [12.2 程序设计风格](#122-程序设计风格)
    - [12.2.1 提高可重用性](#1221-提高可重用性)
    - [12.2.2 提高可扩充性](#1222-提高可扩充性)
    - [12.2.3 提高健壮性](#1223-提高健壮性)
  - [12.3 测试策略](#123-测试策略)
    - [12.3.1 面向对象的单元测试](#1231-面向对象的单元测试)
    - [12.3.2 面向对象的集成测试](#1232-面向对象的集成测试)
    - [12.3.3 面向对象的确认测试](#1233-面向对象的确认测试)
  - [12.4 设计测试用例](#124-设计测试用例)
    - [12.4.1 测试类的方法](#1241-测试类的方法)
    - [12.4.2 集成测试方法](#1242-集成测试方法)
  - [12.5 小结](#125-小结)
- [13 软件项目管理](#13-软件项目管理)
  - [13.1 估算软件规模](#131-估算软件规模)
    - [13.1.1 代码行技术](#1311-代码行技术)
    - [13.1.2 功能点技术](#1312-功能点技术)
  - [13.2 工作量估算](#132-工作量估算)
    - [13.2.1 静态单变量模型](#1321-静态单变量模型)
    - [13.2.2 COCOMO2模型](#1322-cocomo2模型)
  - [13.3 进度计划](#133-进度计划)
    - [13.3.1 估算开发时间](#1331-估算开发时间)
    - [13.3.2 Gantt图](#1332-gantt图)
    - [13.3.3 工程网络](#1333-工程网络)
    - [13.3.4 估算工程进度](#1334-估算工程进度)
    - [13.3.5 关键路径](#1335-关键路径)
    - [13.3.6 机动时间](#1336-机动时间)
  - [13.4 人员组织](#134-人员组织)
    - [13.4.1 民主制程序员组](#1341-民主制程序员组)
    - [13.4.2 主程序员组](#1342-主程序员组)
    - [13.4.3 现代程序员组](#1343-现代程序员组)
  - [13.5 质量保证](#135-质量保证)
    - [13.5.1 软件质量](#1351-软件质量)
    - [13.5.2 软件质量保证措施](#1352-软件质量保证措施)
  - [13.6 软件配置管理](#136-软件配置管理)
    - [13.6.1 软件配置](#1361-软件配置)
    - [13.6.2 软件配置管理过程](#1362-软件配置管理过程)
  - [13.7 能力成熟度模型](#137-能力成熟度模型)
    - [13.7.1 初始级](#1371-初始级)
    - [13.7.2 可重复级](#1372-可重复级)
    - [13.7.3 已定义级](#1373-已定义级)
    - [13.7.4 已管理级](#1374-已管理级)
    - [13.7.5 优化级](#1375-优化级)
  - [13.8 小结](#138-小结)

<!-- /TOC -->

# 1. 软件工程学概述
## 1.1 软件危机
软件危机：是指计算机软件的开发和维护过程中所遇到的一系列严重的问题。 

### 1.1.1 软件危机的介绍
- 对软件开发成本和进度的估计常常很不准确。
- 用户对“已完成的”软件系统不满意的现象经常发生。
- 软件产品的质量往往靠不住。
- 软件常常不可维护的。
- 软件通常没有适当的文档资料。
- 软件在计算机系统总成本中所占的比例逐年上升。
- 软件开发生产率提高的速度，远远比不上计算机应用迅速普及深入的趋势。
  

### 1.1.1软件危机产生的原因
  
   
### 1.1.1消除软件危机的途径
   

## 1.2 软件工程
### 1.2.1 软件 =  程序 + 数据 + 文档  
- 程序： 计算机可以接受的一系列的指令，运行时可以提供所要求的功能和性能。   
- 数据： 使得程序能够适当地操作信息的数据结构。  
- 文档： 描述程序的研制过程，方法和使用的图文资料。  


### 1.2.2 介绍   
- 概括：软件工程是指导计算机软件**开发和维护**的一门工程学科。  
- 早期定义：软件工程就是为了经济地获得可靠的且能在实际机器运行的软件，而**建立和使用完善的工程原理**。   
- 更全面具体的定义：软件工程就是：把系统的、规范的、可度量的途径的应用于软件开发、运行和维护过程，也就是把工程应用于软件。

### 1.2.3 基本原理
- 用分阶段的生命周期计划严格管理。
- 坚持进行阶段评审。
- 实行严格的产品控制。
- 采用现代程序设计技术。
- 结果应能清楚地审查。
- 开发小组的人员应该少而精。
- 承认不断改进软件工程实践的必要性。

### 1.2.4 方法学   
软件工程包括**技术**和**管理**两方面的内容，是技术与管理紧密结合所形成的工程学科。
软件工程学包含3要素：**方法**、**工程**和**过程**。

#### 1.2.4.1 传统方法学  
传统方法学也称为**生命周期方法学**或**结构化泛型**。采用结构化技术（结构化分析、结构化设计和结构化实现）来完成软件开发的各项任务。  
- 前一个任务的完成是开始进行后一个阶段工作的前提与基础，后一个阶段任务的完成通常是使前一个阶段提出解法更进一步具体化，加进了更过的实现细节。  
- **审查**的一条主要标准就是**每个阶段**都应该交出“最新式的”高质量的文档资料，从而保障在软件开发工程结束时有一个完整准确的软件配置交付使用，**文档**是通信的工具。

#### 1.2.4.2 面向对象方法学
面向对象方法把**数据**和**行为**看成同等重要的，它是一种以数据为主线，把数据和对数据的操作紧密结合起来的方法。  
**4个要点：**
- 把对象作为融合了数据及在数据上的操作行为的统一的软件构件。
- 把所有对象都划分成类。
- 按照父类与子类的关系，把若干个相关类组成一个层析结构的系统（也称为类等级）。
- 对象彼此间仅能通过发消息互相联系。
  

## 1.3 软件生命周期
软件生命周期由**软件定义、软件开发**和**运行维护**（也称“软件维护”）3个时期组成。

**软件定义**
- 问题定义：  
  **回答**：“要解决的问题是什么？”！  
  **这个阶段要做的事**：定义问题。  
- 可行性研究：  
  **回答**：“对于上一个阶段确定的问题有行得通的解决方法吗？” ！   
  **这个阶段要做的事**：研究问题的范围，探索这个问题是否值得去解，是否有可行的
  解决方法。
- 需求分析：  
  **回答**：“为了解决这个问题，目标系统必须做什么？”！      
  **这个阶段要做的事**：**系统逻辑模型**是以后设计和实现目标系统的基础，因此必须准确完整地体现用户的要求。这阶段的一项重要的任务，是用正式文档准确地记录对目标系统的需求，这份文档通常称为**规格说明书**（specification）。
  

**软件开发**
- 总体设计（概要设计）  
  **回答**：“概括地说，应该怎样实现目标系统？”！  
  **这个阶段要做的事**：设计多种方案，并制定出最佳方案的详细计划。（设计程序的体系结构，也就是确定程序是由哪些模块组成以及模块间的关系。）
  
- 详细设计  
  **回答**：“应该怎样具体实现这个系统呢？”！  
  **这个阶段要做的事**：设计程序的详细规格的说明，需要包含必**要的细节**，程序员可以根据它们写出实际的程序代码。
- 编码与单元测试  
  写出正确的容易理解、容易维护的程序**模块**。

**单元测试**
- 综合测试
  通过各种类型的测试使软件达到预期的要求。
- 运行维护（软件维护）
  通过各种必要的维护活动使系统持久地满足用户的需要。


## 1.4 软件过程

描述为了开发出客户需要的软件、什么人（who）、在什么时候（when）、做什么事（what）以及怎样（how）做这些事以实现某一个特定的具体目标。   
**ISO定义**：使用资源将输入转化为输出的活动所构成的系统。

### 1.4.1 瀑布模型
传统软件工程方法学的软件过程，基本上可以用瀑布模型描述。瀑布模型是**文档驱动**的模型。


- 特点
  - 阶段间具有顺序性和依赖性  
  只有前一阶段的输出文档正确，后一阶段的工作才能获得正确的结果。
  - 推迟实现的观点  
  清楚地区分逻辑设计与物理设计，尽可能推迟程序的物理实现，是按照瀑布模型开发软件的一条重要思想。
  - 质量保证的观点
    - 每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。
    - 每个阶段结束前都要对所完成的文档进行评审。

- 优点
  - 强迫开发人员采用规范的开发方法。
  - 严格规定了每个阶段必须提交的文档。
  - 要求每个阶段交出的所有产品都必须经过质量验证。




### 1.4.2 快速原型模型
快速建立一个**能反映用户主要需求的原型系统**，让用户在计算机上试用它，通过实践来了解目标系统的概貌。

过程：开发人员按照用户的引荐快速地修改原型系统，然后再次请用户试用。

本质：快速原型的本质是“快速”，开发人员应该尽可能快地建造出原型系统，以加速软件开发过程，节约软件开发成本。原型的用途是获知用户的真正需求。

软件产品的开发基本上是线性顺序进行的。
- 原型系统已经通过与用户交互而得到验证，据此产生的规格说明文档正确地描述了用户需求，因此，在开发过程的后续阶段不会因为发生了规格说明文档的错误而进行较大的返工。
- 开发人员通过建立原型系统已经学习到了许多东西。
  

### 1.4.3 增量模型（渐增模型）
使用增量模型开发软件时，把软件产品作为一系列的**增量构件**来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并能够完成特定的功能。  
增量模型是逐步分批向用户提交产品。  
使用增量模型的困难：是把每个新的增量构件集成到现有的软件体系结构中时，必须不破坏原来已经开发的产品。


### 1.4.4 螺旋模型
使用原型及其他方法来尽量降低风险。理解这种模型的一种简便方法是把它看作每个阶段之前都增加了风险分析过程的快速原型模型（风险驱动的）。


### 1.4.5 喷泉模型
喷泉模型是典型的面向对象的软件过程之一。
“喷泉”一词体现了面向对象的软件过程模型之一。

### 1.4.6 Rational统一过程
Rational统一过程（Rational Unified Process， RUP），总结了经过多年商业化验证的6条最有效的软件开发经验。被称为“最佳实践”。


**最佳实践**
1. 迭代式开发：整个软件开发过程中客户的需求会经常改变，因此需要有一种能够通过一系列细化的、若干的渐进的反复的过程而得出有效解决方案的迭代方法。
2. 管理需求：确定系统需求是一个连接的过程。RUP采用用例分析来捕获需求。
3. 使用基于构件的体系结构：所谓构件就是功能清晰的模块或子系统。
4. 可视化建模：所谓模型，就是为了理解事物而对事物做出一种抽象，是对事物的一种无歧义的书面描述。
5. 验证软件质量：软件质量式内建在贯穿于整个开发过程的、由全体成员参与的所有的活动中。
6. 控制软件变更：RUP描述了如何控制、跟踪和监控修改，以确保迭代开发的成功。

RUP软件开发生命周期
1. 核心工作流（9个）
- 业务建模
- 需求
- 分析与设计
- 实现
- 测试
- 部署
- 项目管理
- 环境


2. 工作阶段
- 初始阶段：建立业务模型，定义最终产品视图，并确定项目的范围。
- 精化阶段：设计并确定系统体系结构，制定项目计划，确定资源需求。
- 构建阶段：开发出所有构件和应用程序，把它们集成为客户需要的产品，并且详尽地测试所有功能。
- 移交阶段：把开发出的产品提交给用户使用。


3. RUP迭代式开发：RUP重复一系列组成软件生命周期的循环。每次循环都经历一个完整的生命周期。每个阶段又进一步细分为一次或多次迭代过程。


### 1.4.7 敏捷过程和极限编程
### 1.4.7.1 敏捷过程——价值观 
1. 个体和交互胜过过程和工具：致力于构件软件开发团队（包括成员的交互方式等） ，然后再根据需要为团队配置项目环境。
2. 可以工作的软件胜过面面俱到的文档：开发人员应该把主要精力放在创建可工作的软件上，仅当迫切需要并且具有重大意义时，才进行文档编制工作。
3. 客户合作胜过合同谈判：开发团队与客户密切合作。  
4. 响应变化胜过遵循计划：一个软件过程必须反映现实，因此，软件过程应该有足够的能力及时响应变化。 

### 1.4.7.2 极限编程（敏捷过程的具体落实）
1. 有效实践
- 客户作为团队的开发人员
- 使用用户素材
- 短交互周期
- 验收测试
- 结对编程
- 测试驱动开发
- 集体所有
- 持续集成
- 可持续的开发速度
- 开放的工作空间
- 及时调整计划
- 简单的设计
- 重构
- 使用隐喻


2. 整体开发过程：提出需求，满足需求，1-3周进行迭代一次。

3. 迭代过程


有效实践  

### 1.4.8 微软过程
1. 过程准则
2. 生命周期（5个阶段）
- 规划阶段：从市场获得的用户情况和客户需求等信息。完成：
>确定产品目标
获取竞争对手的信息。  
完成对客户和市场的调研分析。  
确定对新版本产品应该具备的主要特征。  
确定相对于前一版本而言，新版本应该解决的问题和需要增加的功能。

- 设计阶段：项目团队完70%的产品需求时，开发工作进入到设计阶段。主要工作：
> - 根据产品目标编写系统的特征规格说明书。说明书主要描述：**软件特征、系统结构、各构件间的相关性以及接口标准**。
> - 从系统的**高层进行设计**，主要完成下述工作：简明扼要描述整个系统的**设计方案，绘制系统结构图，确定系统中存在的风险因素，分析系统的可重用性。**
>  - 划分出系统的子系统，给出各个子系统和各个构件的规格说明。
>  - 根据产品特征规格说明书，制定产品开发计划。

- 开发阶段：完成产品中所有构件的开发工作。

- 稳定阶段
- 发布阶段

### 1.4.9 小结

**生命周期的要点：**
- 软件生命周期的各个阶段完成一些确定的任务，交出最终的软件配置的程序或文档。
- 在每个阶段任务是采用结构化技术和适当的软件工具。
- 在每个阶段结束之前都进行严格的技术审查和管理复审。

当软件规模庞大或对软件需求模糊易变时，采用生命周期方法学开发往往不成功。

**面向对象方法的的4个要点：**
**面向对象方法 = 对象 + 类 + 继承 + 用消息通信**





# 2. 可行性研究

目的：就是用最小的代价在尽可能短的时间内确定问题是否能够解决。  

## 2.1 可行性研究的任务
技术可行性：使用现有的技术能实现？   
经济可行性  
操作可行性：系统的操作方式在这个用户组织内行得通？  

## 2.2 可行性研究过程
- 复查系统规模和目标
- 研究目前正在使用的系统
- 导出新系统的高层逻辑模型：导出现有的系统的逻辑模型，设想目标系统的逻辑模型，最后根据目标系统的逻辑模型建造新的物理系统.
- 进一步定义问题
- 导出和评价供选择的解法：分析员应该从他建议的系统逻辑模型出发，导出若干个较高层次的物理解法供比较和选择。
- 推荐行动方针
- 草拟开发计划
- 书写文档提交审查


## 2.3 系统流程图

概括地描绘物理系统的传统工具

系统流程图表达的是数据在系统各个部件之间的流动情况，而不是对数据进行加工处理。这个是物理数据流图而不是程序流程图。
- 符号
- 例子
- 分层：分层次描绘这个系统
  
  
## 2.4 数据流图（DFD）
一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换。

- 符号
- 例子
- 命名
- 用途：
  - 分析和设计的工具
  - 描绘系统的整体逻辑概貌
  - 辅助物理系统的设计


## 2.5 数据字典
是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。

- 数据字典的内容
  - 组成元素
    - 数据流
    - 数据流分量（即数据元素）
    - 数据存储
    - 处理
  
- 定义数据的方法：数据字典中的定义就是对数据自顶向下的分解。
  
- 数据字典的用途：作为分析阶段的工具，在数据字典中建立的一组严密一致的定义很有助于改进分析员和用户之间的通信。
  
- 数据字典的实现


## 2.6 成本/效益
- 成本估计
  - 代码行技术
  - 任务分解技术
  - 自动估计成本技术
- 成本/效益分析的方法


## 小结
- 可行性研究进一步探究问题定义阶段所确定的问题是否有可行的解。
- 可行性分析的基本目的是用较小的成本在较短的时间内确定是否存在可行的方法。


# 3. 需求分析

- 需求分析是**软件定义**的最后一个阶段，它的基本任务是回答“系统必须做什么”。
- 需求分析的任务还不是明确对目标系统提出完整的、准确的、清晰的、具体的要求。  


## 3.1 需求分析的任务    
- 确定对系统的综合要求  
  - 需求分析：指系统必须提供的服务  
  - 性能需求  
  - 可靠性和可用需求  
  - 出错处理需求  
  - 接口需求：描述应用系统与它的环境的通信的格式
  - 约束
  - 逆向需求：说明软件系统不应该做什么。
  - 将来可能提出的要求

- 分析系统的数据要求：任何一个软件系统本质上是**信息处理系统**，系统必须处理的信息和系统产生的信息在很大程度上决定了系统面貌。   
- 导出系统的逻辑模型  
- 修正系统开发计划  

## 3.2 与用户沟通获取需求的方法  
- 访谈
  - 最早使用的获取用户需求的技术
  - 正式和非正式的访谈
  - 情景分析技术  
    用处：  
    - 某种程度上演示目标系统的行为
    - 让用户积极主动参与
  
- 面向数据流自顶向下求精  
  - 结构化方法就是面向数据流自顶向下逐步求精进行需求分析的方法。
  - 数据流图细化
  
- 简易的应用规格说明技术：面向团队的需求法。  
  典型过程：

- 快速建立软件原型：快速建立起来的旨在演示目标系统的主要功能的可运行程序。

## 3.3 分析建模与规格说明
  
- 分析建模：所谓建模就是为了理解事物而对事物作出的一种抽象，是对事物一种无歧义的书面描述。
  - 数据模型
  - 功能模型：数据流图是建立功能模型的基础
  - 行为模型
- 软件需求规格说明：软件需求问规格说明书，它是需求分析阶段得出的**最主要的文档**。


## 3.4 实体-联系图
- 数据对象
- 属性
- 联系
- 实体-联系图的符号

## 3.5 数据规范化
范式：定义消除数据冗余的程度。

## 3.6 状态转化图
- 状态：是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。  
状态图：即可表示系统循环运行过程，也可以表示系统单程生命周期。
- 事件：某个特定时刻发生的事件，它是对引起系统做动作或从一个状态转换到另一个状态的外界事件的抽象
- 符号
- 例子
  
## 3.7 其他图形工具
- 层次方框图：用**树形结构**的一系列多层次的矩形框**描绘数的层次结构**。
- Warnier图：树结构，比“层次方框图”类似。
- IPO图：输入、处理、输出的图的简称。
  
## 3.8 验证软件需求
- 从哪些方面验证软件需求的正确性
  - 一致性：**所有的需求必须是一致的**，任何一条需求的不能和其他的需求矛盾。
  - 完整性：需求必须的完整的，规格说明书应该包括用户需要的每一个功能或性能。
  - 现实性：从现有的技术水平出发判断需求的现实性。
  - 有效性：必须证明需求的正确有效的，确实能解决用户面对的问题。

- 验证软件需求的方法
  - 验证需求一致性
  - 验证需求的现实性
  - 验证需求的完整性和有效性：只有目标系统用户才真正知道软件需求的规格说明书。 
- 用于需求分析的软件工具
  - RSL（需求陈述语言）
  - PSL/PSA（问题陈述语言/问题陈述分析程序）
  - CADSAT（计算机辅助设计和规格说明分析工具）

## 小结


# 4. 形式化说明技术

- 非形式化方法的缺点：用自然语言描述需求规格说明。
- 形式化方法的优点：描述系统性质的基本教学的技术，也就是说如果有一种方法有坚实的数学基础，那么它是形式化的。
- 半形式化方法的优点：用数据流图或实体-联系图建立模型。


## 4.1 概述
- 非形式化方法的缺点：用自然语言书写的系统规格说明书，可能存在矛盾、二义性、含糊性、不完整性及抽象层次混乱等问题。
- 形式化方法的优点：
- 应用形式化方法的准则
  
## 4.2 有穷状态机
利用此可准确地描述一个系统，因此它是表达规格说明的一种形式化方法。
- 概念
- 例子
- 评价
  
## 4.3 Petri网
用于确定系统中隐含的定时问题的一种有效技术
- 概念
- 例子
  
## 4.4 Z语言
- 简介
- 评价


# 5. 总体设计（概要设计）
回答：“ 概括地说，系统应该如何实现”这个问题。  
过程首先寻找实现目标系统的各种不同的方案，选择最合理的方案。  
必要性：可以站在全局高度上，花较少的成本从较抽象的层次上分析对比多种可能的实现系统方案和软件结构。

## 5.1 设计过程
- 两个主要阶段
  - 系统设计阶段：确定系统的具体实现方案
  - 结构设计阶段：确定软件架构
- 典型总体设计的9大步骤
- 设想供选择的方案
- 选取合理的方案
- 推荐最佳方案
- 功能分解：结构设计是总体设计阶段的任务，过程设计是详细设计阶段的任务
- 设计软件架构
- 设计数据库
- 指定测试计划
- 书写文档
  - 系统说明
  - 用户手册
  - 测试计划
  - 详细的实现计划
  - 数据库的设计结果
- 审查和复审

## 5.2 设计原理
- 模块化：就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。
- 抽象：把这些相似的方面集中和概括起来，暂时忽略他们的之间的差异，这就是抽象，或者说抽象就是抽出事物的本质特征而暂时不考虑它们的细节
处理复杂系统的唯一有效的方法是层次的方式构造和分析它
- 逐步求精：求精实际上就是细化的过程，抽象与求精是一对互补的概念。“为了能集中精力解决主要问题而尽量推迟对问题细节的考虑”。
- 信息隐藏和局部化
  - 信息隐藏；指出，应该这样设计和确定模块，使得一个模块内包含的信息（过程和数据）对于不需要这些信息的模块来说，是不能访问的。
  - 局部化：指把一些关系密切的软件元素物理地放得彼此靠近。
- 模块独立：
  - 概念：模块化、抽象、信息隐藏、局部化概念的直接结果
  - 衡量：内聚和耦合
    - 耦合：衡量不同模块彼此间互相依赖的紧密程度
    - 内聚：衡量一个模块内部各个元素彼此结合的紧密程度

## 5.3 启发规则
- 改进软件结构提高模块独立性
- 模块规模应该适中
- 深度、宽度、扇出和扇入都应适当
- 模块的作用域应该在控制域之内
- 力争降低模块接口的复杂程度
- 设计单入口和单出口
- 模块功能应该可以预测
  
## 5.4 描绘软件结构的图形工具（模块）
- 层次图和HIPO图：层次图用来描绘软件层次结构
- 结构图
  
## 5.5 面向数据流的设计方法
面向数据流的设计方法的目标是给出设计软件结构的一个系统化的途径。
- 概念：把信息流映射成软件结构。
  - 变换流：信息通常以“外部世界“的形式进入软件系统，经过处理以后再以”外部世界“的形式离开系统
  - 事务流：以事务为中心
  - 设计过程
- 变换设计：把具有变换流特点的数据流图按预先确定的模式映射软件结构。
- 事物分析
- 设计优化

## 5.6 小结
- 基本目的：用比较抽象概括的方式确定系统如何完成预定的任务
- 步骤   
系统设计：从数据流图出发设想完成系统功能的若干种合理的物理方案。  
软件结构设计：确定软件有哪些模块组成以及这些模块之间的动态调用关系。  
层次图和结构图是描绘软件结构的常用工具。


# 6. 详细设计
根本目的：确定应该怎么具体地实现1所要求的系统。  
详细设计的目标不仅仅是逻辑上正确地实现每个模块的功能，更重要的是设计出处理**过程**应该尽可能**简明易懂**。结构程序设计技术是实现上述目标的关键技术，因此是详细设计的逻辑基础。

## 6.1 结构程序设计
- 经典定义：如果一个程序的代码仅仅通过顺序、选择和循环这3种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。

## 6.2 人机界面设计
- 设计问题：最好在设计初期就把这些问题作为重要的设计问题来考虑。
  - 系统响应时间
  - 用户帮助设施
  - 出错信息处理：出错信息和警告信息，是出现问题时交互式系统给出的“坏消息”
  - 命令交互
- 设计过程：用户界面设计是一个迭代的过程。
  评估方法：
  - 系统及其界面的规格说明书。。。。
  - 命令或动作的数量。。。
  - 设计模型种包含的动作、命令和系统状态的数量。。。
  - 界面风格、帮助措施和出错处理协议。。。
- 人机界面设计**指南**
  - 一般交互指南：一致性，，，，
  - 信息显示指南：
  - 数据输入指南


## 6.3 过程设计的工具

-  程序流程图
-  盒图
-  PAD图（问题分析图）  
  优点：  
   - 设计出来的必定是：结构化程序
   - 自上而下，从左到右
   - 转化为高级语言容易
- 判定表
能够清晰表示复杂的条件的组合与应做的动作之间的对应关系
- 判定树
- 过程设计语言（PDL，也称伪码）：表示实际操作和条件的内部语法通常又是灵活自由的，可以适应各种工程项目的需要。  
特点：
  - 关键字固定语法
  - 子网语言的自由语法
  - 数据说明的手段
  - 模块定义和调用的技术

## 6.4 面向数据结构的设计方法
计算机软件**本质**是**信息处理系统**。  
面向数据结构的设计方法，的最终目标是得出对**程序处理过程的描述**。

- Jackson图
  - 顺序结构
  - 选择结构
  - 重复结构
- 改进的Jackson图：与层次图的关系——一种精化  
层次图：一个方框通常代表一个模块。   
jackson图：表示描绘程序结构时，一个方框并不代表一个模块，通常一个方框只代表几个语句。表示组成关系，一个方框种包括的操作仅仅由它下层框中的那些操作组成。  
- Jackson方法  
  5个步骤组成：    
  - 分析并确定**输入数据和输出数据的逻辑结构**
  - 找出输入数据和输出数据结构中有对应关系的数据单元
  - 导出描绘程序的结构的Jackson图
    - 为每对有对应关系的数据，按照它们在数据结构图中层次在程序结构图中相应层析画一个处理框
    - 根据出入数据结构中剩余的每个数据单元的所处的层次，在程序结构图的相应层析为它们画上对应的处理框
    - 根据输出数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次为让门画上对应的处理框
  - 列出所有操作和条件
  - 用伪码表示程序

## 6.5 程序复杂程度的定量度量
通过某些科学的方法衡量它们的质量。

### McCabe方法
根据程序的**控制流的复杂**程度定量度量程序的复杂程度。
### Halstead方法
根据**运算符和操作数**的总数来度量程序的复杂程度.


# 7. 实现
通常把编码和测试统称为实现。所谓编码就是把软件设计结果翻译成用某种程序设计语言书写的过程。

## 7.1 编码
### 7.1.1 选择程序设计语言
### 7.1.2 编码风格
- 程序内部的文档
- 数据说明
- 语句构造
- 输入输出
- 效率
  - 程序运行的时间
  - 存储器效率
  - 输入输出的效率
## 7.2 软件测试基础
### 7.2.1 软件测试的目标
### 7.2.2 软件测试准则
### 7.2.3 测试方法
### 7.2.4 测试步骤
- 模块测时
- 子系统测试
- 系统测试
- 验收测试
- 平行运行
### 7.2.5 测试阶段的信息流

## 7.3 单元测试
### 7.3.1 测试重点
- 模块接口
- 局部数据结构
- 重要的执行通路
- 出错处理通路
- 边界条件
## 7.4 集成测试
### 7.4.1 自顶向下集成
### 7.4.2 自底向上集成
### 7.4.3 不同集成测试策略的比较
### 7.4.4 回归测试
## 7.5 确认测试
### 7.5.1 确认测试的范围
### 7.5.2 软件配置复查
### 7.5.3 Alpha和Beta测试
## 7.6 白盒测试技术
### 7.6.1 逻辑覆盖
### 7.6.2 控制结构测试
## 7.7 黑盒测试技术
### 7.7.1 等价划分
### 7.7.2 边界值分析
### 7.7.3 错误推测
## 7.8 调试
### 7.8.1 调试过程
### 7.8.2 调试途径
## 7.9 软件可靠性
### 7.9.1 基本概念
- 软件可靠性的定义
定义：是程序在给定时间的间隔内按照规格说明书的规定成功运行的概率
- 软件的可用性
对于任何其故障可以修复的系统，都应该同时使用可靠性和可用性衡量它的优劣程度
### 7.9.2 估算平均无故障时间的方法

     
# 8. 维护
## 8.1 软件维护的定义



## 8.2 软件维护的特点
### 8.2.1 结构化维护和非结构化维护的巨大差别
- 结构化维护：从评价设计文档开始，确定软件重要的的结构特点、性能特点以及接口特点。
- 非结构化维护
### 8.2.2 维护的代价高昂
### 8.2.3 维护的问题很多


## 8.3 软件维护的过程
- 维护组织
- 维护报告
- 维护的事件流
- 保存维护记录
- 评价维护活动

## 8.4 软件的可维护性
### 8.4.1 决定软件可维护性的因素
- 可理解性：表示为外来读者理解软件的结构、功能、接口和内部处理过程的难易程度。
- 可测试性
- 可修改性
- 可移植性
- 可重用性

  
### 8.4.2 文档
文档是影响软件可维护性的**决定因素**。文档比代码更重要。

- 用户文档：是用户了解系统的第一步，应该能使用户获得对系统的准确的初步印象。
- 系统文档：指从问题定义、需求说明到验收测试计划这样一系列和系统实现有关的文档。
  
### 8.4.3 可维护复审


## 8.5 预防性维护

## 8.6 软件再工程过程
- 库存目录分析
- 文档重构
- 逆向工程
- 代码重构
- 数据重构
- 正向工程


# 9. 面向对象方法学的引论

## 9.1 概述
4个要点:
- 任何事物都是对象
- 把所有对象都划分成各种对象类（class）
- 按照子类和父类的关系，把若干对象类组成一个层次结构的系统
- 对象彼此之间仅能通过传递消息互相联系

**只有同时使用对象、类、继承和消息的方法，才是真正面向对象的方法。**

### 9.1.2 优点
对象之间通过传递消息互相联系，以模拟现实世界中不同事物彼此之间的联系。
- 与人类习惯思维方法一致：
  - 面向对象的软件技术以对象为核心。对象是对现实世界的正确抽象，它是由描述内部状态表示静态属性的数据。
  - 面向对象方法学的**基本原则**：按照人类习惯的思维方式建立问题域的模型。
- 稳定性好：以对象为中心构造软件。系统结构是根据问题领域的模型建立起来的，并不会引起软件结构的整体变化。
- 可重用性好
- 较易开发大型软件产品
- 可维护性好


## 9.2 概念
### 9.2.1 对象
在应用领域中有意义的、与所要解决的问题有关系的任何事物都可以作为对象。在面向对象分析和面向对象设计中，通常把对象的操作称为服务或方法。
- 对象的形象表示：
- 对象的定义
  - 对象是具有相同状态的一组操作的集合。（从面向对象程序设计的角度看“对象”）
  - 对象是对问题域中某个东西的抽象，这种抽象反映了系统保存有关这个东西的信息或与它交互的能力。也就是说，**对象是对属性值和操作的封装**。（从信息模拟的角度）
  - 对象：：=<ID，MS， DS， MI>，其中，ID是对象的标识和名字，MS是对象中的操作集合，DS是对象的数据结构，MI是对象受理的消息名集合。（形式化的定义）
- 对象的特点
  - 以数据为中心
  - 对象是主动的
  - 实现了数据封装：对象好像是一个黑盒子，它的私有数据完全被封装到盒子内部，对外是隐藏的、不可见的。
  - 本质上具有并行性
  - 模块独立性好


### 9.2.2 其他概念
- 类（class）：是对具体相同属性和行为的一个或多个对象的描述，通常在这种描述中也包括对怎样创建该类的新对象的说明。
- 实例（instance）：类是建立对象的模板。
- 消息（message）：就是要求某个对象执行在定义它的那个类中所定义的某个操作的规格的说明。
- 方法（method）：对象所能执行的操作，也就是类的所定义的服务。
- 属性（attribute）：类中定义的数据，它是对客观世界实体所具有的性质的抽象。
- 封装（encapsulation）：信息隐藏，通过封装对外界隐藏了对象的实现细节。
- 继承（inheritance）广义：是指能够直接获得与已有的性质和特征，而不必重复定义它们。继承是子类自动共享基类中定义的数据和方法的机制。
- 多态（polymorphism）：多态意思“有许多形态”，指子类对象可以像父类对象那样使用，同样的消息既可以发送给父类对象也可以发送给子类对象。
- 重载（overloading）：指在同一作用域内的若干参数特征不同的函数可以使用相同函数名字。

## 9.3 面向对象建模
建模：就是为了理解事物而对事物作出的一种抽象，是对事物的一种无歧义的书面描述。
对象模型始终都是最重要、最基本、最核心的。

## 9.4 对象模型
对象模型表示静态的、结构化的系统的“数据”性质。

### 9.4.1 类图的基本符号
- 定义类
- 定义属性
- 定义服务
  
### 9.4.2 表示关系的符号
- 关联：表示两个类的对象之间的存在某种语义上的联系。
- 聚集：也称聚合，表示类与类之间的关系是整体与部分的关系。
- 泛化：就是通常所说的**继承关系**，它是通用元素和具体元素之间的一种分类关系。
- 依赖和细化
  - 依赖关系：描述模型元素（类、用例等）之间的语义连接关系。
  - 细化关系：当统一事物在不同的抽象层次上描述时，这些描述之间具有细化关系。


## 9.5 动态模型
动态模型表示瞬时的、行为化的系统的系统的“控制”性质，它规定了对象模型中的对象的合法变化序列。

## 9.6 功能模型
功能模型由一组数据流图组成，在面向对象方法学中，数据流图远不如在结构分析、设计方法中那么重要。用例模型描述的时**外部行为者**（actor）所理解的系统功能，用例模型的建立是系统开发者和用户反复讨论的结果，它描述了**开发者和用户**对需求规格所达成的共识。


### 9.6.1 用例图

一副用例图包含的模型元素有系统、行为者、用例和用例之间的关系。
- 系统：系统可以看作是一个提供用例的黑盒子。
- 用例：一个用例是可以被行为者感受到的、系统的一个完整的功能。
- 行为者：是指域系统交互的人或其他系统，它代表**外部实体**。行为者是一种角色，而不是某个具体的人或物。
- 用例之间的关系
  - 扩展关系
  - 使用关系
  
### 9.6.2 用例建模
- 寻找行为者
- 寻找用例
  
## 9.7 3种模型之间的关系
- 功能模型：指明了系统应该“做什么”。
- 动态模型：明确规定了什么时候（即在何种状态下接受了什么事件的触发）。
- 对象模型：则定义了做事情的实体。 

## 9.8 小结
3种不同模型，描述系统静态结构的对象模型，描述系统控制结构的动态模型以及描述系统计算机结构功能模型，其中**对象模型**是最基本、最核心、最重要的。




# 10. 面向对象分析
分析的过程都是提取系统需求的过程，分析工作3项内容：**理解**、**表达**、**验证**。

## 10.1 基本过程

### 10.1.1 概述
面向对象分析，就是抽取和整理用户需求并建立问题域精确模型的过程。

### 10.1.2 3个子模型与5个层次
面向对象建模得到的模型包含系统的3个要素。
- 3子模型
  - 静态结构（对象模型）
  - 交互次序（动态模型）
  - 数据交换（功能模型）
  
复杂问题（大型系统）的对象模型通常由下述5个层次：
- 5层次
  - 主题层
  - 类与对象层
  - 结构层
  - 属性层
  - 服务层
  
## 10.2 需求陈述
### 10.2.1 书写要点
阐明“做什么”而不是“怎么做”
### 10.2.2 例子
## 10.3 建立对象模型
面向对象分析首要工作，是建立问题域的对象模型。这个模型描述了现实世界中的“类与对象”以及它们之间的关系，表示了目标系统的静态数据结构。

### 10.3.1 确定类与对象
- 找出候选的类与对象
- 筛选出正确的类与对象
  - 冗余
  - 无关
  - 笼统
  - 属性
  - 操作
  - 实现


### 10.3.2 确定关联

- 确定类与对象之间的关联
  - 初步确定关联
  - 直接提取动词短语得出的关联
  - 需求陈述中隐含的关联
  - 根据问题域知识得出的关联


- 筛选
  - 已删去的类之间的关联
  - 与问题无关的或应在实现阶段考虑的关联
  - 瞬时事件

- 进一步完善
  - 正名
  - 分解
  - 补充
  - 标明重数

### 10.3.3 划分主题

在开发大型、复杂系统的过程中，降低复杂程度，人们习惯把系统再进一步划分为几个不同的主题，也就是在概念上把系统包含的内容分解成若干个范畴

### 10.3.4 确定属性

属性是对象的性质，籍助于属性人们能够对类与对象和结构有更深入更具体的认识。

- 分析
- 选择
  - 误把对象当作属性
  - 误把关联类的属性当作一般对象的属性
  - 把限定误当成属性
  - 误把内部状态当成了属性
  - 过于细化
  - 存在不一致的属性

### 10.3.5 识别继承关系

继承关系的建立实质上实质是的抽取过程。它反映出一定深度的领域知识。  

一般使用两种方法建立继承（即泛化）关系：
- 自底向上：抽象出现有类的共同泛化出的父类，模拟人类归纳思维过程。
- 自顶向下：把现有类细化成更具体的子类，模拟人类演绎思维过程。

### 10.3.6 反复修改
- 分解“现金兑换卡”类
- “事务”由“更新”组成
- 把“分行”与“分行计算机”合并

## 10.4 建立动态模型

### 10.4.1 编写脚本

### 10.4.2 设想用户界面
### 10.4.3 画事件跟踪图
完整、正确的脚本为建立动态模型奠定了必要的基础。
- 确定事件
- 画出事件跟踪图
  
### 10.4.4 画状态图
描绘事件跟对象状态的关系。

### 10.4.5 审查动态模型
各个类的状态图通过共享事件合并起来，构成了系统的动态模型。


## 10.5 建立功能模型

功能模型表明了系统中数据之间的依赖关系，以及有关的数据处理功能，它由一组数据流图组成。	
### 10.5.1 画出基本系统模型图
基本系统模型由若干个数据源点/终点，以及一个处理框成。这个处理框代表了系统加工、变换数据的整体功能。

### 10.5.2 画出功能级数据流图
把基本系统模型中单一的处理框分解成若干个处理框，以描述系统加工、变换数据的基本功能，就得到功能级数据流程图。

### 10.5.3 描述处理框功能
## 10.6 定义服务
- 常规行为
- 从事件导出的操作
- 与数据流图中处理框对应的操作
- 利用继承减少冗余


## 10.7 小结
分析就是提取系统需求并建立问题域精确模型的过程，它包括理解、表达验证3项主要工作内容。


# 11. 面向对象设计

**分析**是提取和整理用户需求，并建立问题域精确模型的过程。  
**设计**则是把分析阶段得到的需求转变成符合成本的和质量要求的、抽象的系统**实现方案**的过程。   
从面向对象分析到面向对象设计（OOD），是一个逐渐扩充模型的过程。或者说，面向对象设计就是用**面向对象观点建立求解域模型的过程**。  
  
可把面向对象设计再细分为**系统设计**和**对象设计**。
>系统设计确定实现系统的策略和目标系统的高层结构。  
对象设计确定解空间中类、关联、接口、形式及实现服务的算法。


## 11.1 面向对象设计的准则
- 模块化
- 抽象
- 信息隐藏
- 弱耦合
- 强内聚
- 可重用


## 11.2 启发规则
- 设计结果应该清晰易懂
  - 用词一致
  - 使用已有的协议
  - 减少消息模式的数目
  - 避免模糊的定义
- 一般-特殊结构的深度应适当
  - 设计简单的类
  - 避免包含过多的属性
  - 有明确的定义
  - 尽量简化对象之间的合作关系
  - 不要提供太多的服务
- 使用简单的协议
- 使用简单的服务
- 把设计变动减至最小


## 11.3 软件重用
### 11.3.1 概述
- 重用
  - 知识重用
  - 方法和标准的重用
  - 软件成分的重用
- 软件成分的重用级别
  - 代码重用
  - 设计结果重用
  - 分析结果重用
- 典型的可重用软件的成分
  - 项目计划
  - 成本估计
  - 体系结构
  - 需求模型和规格说明
  - 设计
  - 源代码  
  - 用户文档和技术文档
  - 用户界面
  - 数据
  - 测试用例


### 11.3.2 类构件
- 可重用软构件应具备的特点
  - 模块独立强
  - 具有高度可塑性
  - 接口清晰、简明、可靠
- 类构件的重用方式
  - 实例重用
  - 继承重用
  - 多态重用


### 11.3.3 软件重用的效益
- 质量
- 生产率
- 成本

## 11.4 系统分解

- 子系统之间的两种交互方式
  - 客户-供应商关系
  - 平等伙伴关系
- 组织系统的两种方案
  - 层次组织
  - 块状组织

- 设计系统的拓扑结构


## 11.5 设计问题域子系统
- 调整需求
- 重用已有的类
- 把问题域类组合在一起
- 增添一般化类以建立协议
- 调整继承层次
  - 使用多重继承机制
  - 使用单继承机制
- ATM系统实例


## 11.6 设计人机交互子系统
- 分类用户
- 描述用户
- 设计命令层次
  - 研究现有的人机交互含义和准则
  - 确定初始的命令和层次
  - 精化命令层次
- 设计人机交互类

## 11.7 设计任务管理子系统
- 分析并发性
- 设计任务管理子系统
  - 确定事件驱动型任务
  - 确定始终驱动型任务
  - 确定优先任务
  - 确定关键任务
  - 确定协调任务
  - 尽量减少任务数
  - 确定资源需求


## 11.8 设计数据管理子系统
### 11.8.1 选择数据存储管理模式
- 文件管理系统
- 关系数据库管理系统
- 面向对象数据库管理系统

### 11.8.2 设计数据管理子系统
- 设计数据格式
  - 文件系统
  - 关系数据库管理系统
  - 面向对象数据库管理系统
- 设计相应服务
  - 文件系统
  - 关系数据管理系统
  - 面向对象数据库管理系统
### 11.8.3 例子


## 11.9 设计类中的服务
### 11.9.1 确定类中应用的服务
### 11.9.2 设计实现服务的方法
- 设计实现服务的算法
- 选择数据结构
- 算法与数据结构的关系
- 定义内部类和内部操作

## 11.10 设计关联
- 关联的遍历
- 实现单向关联
- 实现双向关联
- 关联对象的实现

## 11.11 设计优化
### 11.11.1 确定优先级

### 11.11.2 提高效率的几项技术
- 增加冗余关联以提高访问效率
- 调整查询次序
- 保留派生属性

### 11.11.3 调整继承关系
建立良好的继承关系时优化设计的一项重要的内容。
- 抽象与具体
- 为提高继承程度而修改类定义
- 利用委托实现行为共享

## 11.12 小结
面向对象设计就是用面向对象观点**建立求解空间模型的过程**。  
优秀设计是使得目标系统在整个生命周期中总开销最小的设计，为获得优秀的设计结果，应该遵循一些基本准则。    
用面向对象方法设计软件，原则上也是先进行总体设计（即系统设计），然后再进行详细设计（对象设计）。  


# 12 面向对象实现
面向对象实现主要包含两项工作：  
>把面向对象设计的结果翻译成用某一种程序语言书写的面向对象程序。    
测试并调试面向对象的程序。


## 12.1 程序设计语言
### 12.1.1 面向对象语言的优点
- 一致的表示方法
- 可重用性
- 可维护性


### 12.1.2 面向对象语言的技术特点
- 支持类与对象概念的机制
- 实现整体-部分（即聚集）结构的机制
- 实现属性和服务的机制
- 类型检查
- 类库
- 效率
- 持久保存对象
- 参数化类
- 开发环境

### 12.1.3 选择面向对象语言
- 将来能否主导地位
- 可重用性
- 类库和开发环境
- 其他因素

## 12.2 程序设计风格

### 12.2.1 提高可重用性
- 提高方法的内聚
- 减小方法的规模
- 保持方法的一致性
- 把策略与实现分开
- 全面覆盖
- 尽量不使用全局变量
- 利用继承机制
- 调用子过程
- 分解因子
- 使用委托
- 把代码封装到类中


### 12.2.2 提高可扩充性
- 封装实现策略
- 不要用一个方法遍历多条关联链
- 避免使用多分支语句
- 精心确定公有方法


### 12.2.3 提高健壮性
预防用户的操作错误
检查参数的合法性
不要预先确定限制条件
先测试后优化


## 12.3 测试策略

### 12.3.1 面向对象的单元测试
当考虑面向对象的软件时，单元的概念改变了。

### 12.3.2 面向对象的集成测试
- 基于线程的测试
- 基于使用的测试


### 12.3.3 面向对象的确认测试




## 12.4 设计测试用例
### 12.4.1 测试类的方法
- 随机测试
- 划分测试
- 基于故障的测试

### 12.4.2 集成测试方法
- 多类测试
- 从动态模型导出测试用例


## 12.5 小结
面向对象方法学把分析、设计和实现很自然地联系在一起了，虽然面向对象设计原则上不依赖于特定的实现环境。  


# 13 软件项目管理
软件工程项目的失败主要是因为管理不善。所谓管理就是通过计划、组织和控制等一系列活动，合理地配置和使用各种资源，以达到既定目标的过程。  

## 13.1 估算软件规模
### 13.1.1 代码行技术
### 13.1.2 功能点技术
- 信息域特征
- 估算功能点步骤

## 13.2 工作量估算
### 13.2.1 静态单变量模型
面向KLOC的估算模型
面向FP的估算模型
### 13.2.2 COCOMO2模型

## 13.3 进度计划

### 13.3.1 估算开发时间
### 13.3.2 Gantt图
### 13.3.3 工程网络
### 13.3.4 估算工程进度
### 13.3.5 关键路径
### 13.3.6 机动时间

## 13.4 人员组织
### 13.4.1 民主制程序员组
### 13.4.2 主程序员组
### 13.4.3 现代程序员组

## 13.5 质量保证
### 13.5.1 软件质量
3个要点：
- 软件需求是度量软件质量的基础。
- 指定的开发标准定义了一组指导软件开发的准则。
- 有一组没有现实描述的隐含需求（例如软件是应该容易维护的）。

### 13.5.2 软件质量保证措施

- 技术复审的必要性
- 走查
- 审查
- 程序正确性证明

## 13.6 软件配置管理
### 13.6.1 软件配置
- 软件配置项
  - 计算机程序
  - 描述计算机程序的文档
  - 数据
- 基线


### 13.6.2 软件配置管理过程
- 标识软件配置中的对象
- 版本控制
- 变化控制
- 配置审计
- 状态报告

## 13.7 能力成熟度模型
由于问题是由人们管理软件过程的方法不当引起的，所以新软件技术的运用不会自动提高软件生产率和质量。
### 13.7.1 初始级
### 13.7.2 可重复级
### 13.7.3 已定义级
### 13.7.4 已管理级
### 13.7.5 优化级

## 13.8 小结
软件工程包括技术和管理两方面的内容，是技术与管理紧密结合的产物。
